<html>
<head>
<title>Effective Scala</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript" src="http://use.typekit.com/bub8efs.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

<!--
<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
-->

<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>

<style>	
	body {
		font-family: times, serif;
		margin: 0 1.0in 0 1.0in;
/*		line-height: 1.3em;*/
	}

	address {
		text-align: center;
	}
	
	.header {
		text-align: center;
		margin-top: 1em;
	}
	
	.rhs {
		text-align: left;
	}
	
	p {
		text-indent: 1em;
		text-align: justify;
	}
	
	.LP {
		text-indent: 0em;
	}
	
	code {
		font-family: "Droid Sans Mono'", monospace;
/*		font-size: 0.75em;*/
		font-size: 0.80em;
	}
	
	address {
		font-family: sans-serif;
	}
	
	h1 {
		font-family: sans-serif;
	}
	
	h2 {
		font-weight: bold;
		font-size: 110%;
		margin-top: 1.5em;
		margin-bottom: 0.05in;
	}
	
	h3 {
		font-size: 100%;
		font-style: oblique;
		margin-top: 1.5em;
		margin-bottom: 0.05in;
	}
	
	pre {
		margin: 0 0.5in 0 0.5in;
	}
	
	dl.rules dt {
		font-style: oblique;
	}
	
	table#toc {
		margin: 0 auto;
	}
	
	/* XXX: apply only to TOC. todo: reapply -- html whatever? */   
	ul {
	/*	list-style-type: none;*/
	}
	
	.algo {
		font-variant: small-caps;
	}
	
	div.explainer {
		margin-left: 3em;
		border-left: 2px solid;
		padding-left: 1em;
	}
	
	.explainer > h3 {
		margin-top: 0px;
		font-style: normal;
	}
	
	.footer {
		font-style: oblique;
		font-size: small;
	}
</style>
</head>

<body>
<p><a href="http://github.com/twitter/effectivescala"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/edc6dae7a1079163caf7f17c60495bbb6d027c93/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub"></a></p>

<h1 class="header">Effective Scala</h1>

<address>Marius Eriksen, Twitter Inc.<br />marius@twitter.com (<a href="http://twitter.com/marius">@marius</a>)<br /><br />[translated by Yuta Okamoto(<a href="http://github.com/okapies">@okapies</a>) and Satoshi Kobayashi(<a href="https://github.com/scova0731">@scova0731</a>)]</address>

<h2>Table of Contents</h2>

<ul>
<li><strong><a href="#序章">序章</a></strong></li>
<li><strong><a href="#整形">整形</a></strong>: <em><a href="#整形-ホワイトスペース">ホワイトスペース</a></em>, <em><a href="#整形-命名">命名</a></em>, <em><a href="#整形-インポート">インポート</a></em>, <em><a href="#整形-中カッコ">中カッコ</a></em>, <em><a href="#整形-パターンマッチ">パターンマッチ</a></em>, <em><a href="#整形-コメント">コメント</a></em></li>
<li><strong><a href="#型とジェネリクス">型とジェネリクス</a></strong>: <em><a href="#型とジェネリクス-戻り型アノテーション">戻り型アノテーション</a></em>, <em><a href="#型とジェネリクス-変位">変位</a></em>, <em><a href="#型とジェネリクス-型エイリアス">型エイリアス</a></em>, <em><a href="#型とジェネリクス-暗黙">暗黙</a></em></li>
<li><strong><a href="#コレクション">コレクション</a></strong>: <em><a href="#コレクション-階層">階層</a></em>, <em><a href="#コレクション-利用">利用</a></em>, <em><a href="#コレクション-スタイル">スタイル</a></em>, <em><a href="#コレクション-性能">性能</a></em>, <em><a href="#コレクション-Javaコレクション">Javaコレクション</a></em></li>
<li><strong><a href="#並行性">並行性</a></strong>: <em><a href="#並行性-Future">Future</a></em>, <em><a href="#並行性-コレクション">コレクション</a></em></li>
<li><strong><a href="#制御構造">制御構造</a></strong>: <em><a href="#制御構造-再帰">再帰</a></em>, <em><a href="#制御構造-Return">Return</a></em>, <em><a href="#制御構造-`for`ループと内包"><code>for</code>ループと内包</a></em>, <em><a href="#制御構造-`require`と`assert`"><code>require</code>と<code>assert</code></a></em></li>
<li><strong><a href="#関数型プログラミング">関数型プログラミング</a></strong>: <em><a href="#関数型プログラミング-代数的データ型としてのケースクラス">代数的データ型としてのケースクラス</a></em>, <em><a href="#関数型プログラミング-オプション">オプション</a></em>, <em><a href="#関数型プログラミング-パターンマッチ">パターンマッチ</a></em>, <em><a href="#関数型プログラミング-部分関数">部分関数</a></em>, <em><a href="#関数型プログラミング-分配束縛(Destructuring bindings)">分配束縛(Destructuring bindings)</a></em>, <em><a href="#関数型プログラミング-遅延">遅延</a></em>, <em><a href="#関数型プログラミング-名前呼び出し">名前呼び出し</a></em>, <em><a href="#関数型プログラミング-`flatMap`"><code>flatMap</code></a></em></li>
<li><strong><a href="#オブジェクト指向プログラミング">オブジェクト指向プログラミング</a></strong>: <em><a href="#オブジェクト指向プログラミング-依存性注入">依存性注入</a></em>, <em><a href="#オブジェクト指向プログラミング-トレイト">トレイト</a></em>, <em><a href="#オブジェクト指向プログラミング-可視性">可視性</a></em>, <em><a href="#オブジェクト指向プログラミング-構造的型(？正確な訳？)">構造的型(？正確な訳？)</a></em></li>
<li><strong><a href="#ガベージコレクション">ガベージコレクション</a></strong></li>
<li><strong><a href="#Java 互換性">Java 互換性</a></strong></li>
<li><strong><a href="#Twitterの標準ライブラリ">Twitterの標準ライブラリ</a></strong>: <em><a href="#Twitterの標準ライブラリ-Futures">Futures</a></em></li>
<li><strong><a href="#Acknowledgments">Acknowledgments</a></strong></li>
</ul>

<h2>他の言語</h2>

<p><a href="index.html">English</a></p>

<p><a id="序章" /></p>

<h2>序章</h2>

<p><a href="http://www.scala-lang.org/">Scala</a>は、Twitterで使われている主なアプリケーションプログラミング言語の一つだ。TwitterのインフラのほとんどはScalaで書かれているし、我々の業務を支える<a href="http://github.com/twitter/">大規模ライブラリ</a>をいくつか持っている。Scalaは極めて効率的だが、一方で大きな言語でもある。我々の経験上、Scalaの適用には細心の注意が必要だ。Scalaの落とし穴は何か？ どの機能を採用し、どれを避けるべきか？ いつ&ldquo;純粋関数型スタイル&rdquo;を用い、いつ控えるべきか？ つまり、我々が見出した&ldquo;Scalaの効果的(effective)な使い方&rdquo;とは何か？ このガイドは、我々の経験を抽出し、一連の<em>ベストプラクティス</em>を提供する小論文にまとめようとするものだ。Twitterは、Scalaを、主に分散システムを構成する大容量サービスの作成に利用している。だから、我々の助言にはバイアスがかかっている。しかし、ここにあるアドバイスのほとんどは、他の問題領域へも自然に置き換えることができるはずだ。これは法律じゃない、だから逸脱は正当化されるべきだ。</p>

<p>Scalaは、簡潔な表現を可能にする数多くのツールを提供している。タイピングが少なければ、読む量も少なくなり、読む量が少なくなれば、大抵はより早く読める。故に、簡潔さは明瞭さを高める。しかし、簡潔さはまた、正反対の効果をもたらす使い勝手の悪い道具ともなりえる。正確さの次に、いつも読み手のことを考えよう。</p>

<p>何よりも、<em>Scalaでプログラムするのだ</em>。君が書いているのはJavaではないし、Haskellでも、Pythonでもない。Scalaのプログラムは、それらのうちのいずれの言語で書かれたものとも違っている。Scalaを効果的に使うには、君の問題をScalaの用語で表現しなければならない。Javaのプログラムを、無理矢理にScalaになおしても仕方がない。ほとんどのやり方で、それはオリジナルより劣ったものになるだろう。</p>

<p>これは、Scalaの入門じゃない。読者は、Scalaに慣れ親しんでいることを前提としている。これからScalaを学びたい人は、以下のサイトを参照するといいだろう:</p>

<ul>
<li><a href="http://twitter.github.com/scala_school/">Scala School</a></li>
<li><a href="http://www.scala-lang.org/node/1305">Learning Scala</a></li>
<li><a href="http://matt.might.net/articles/learning-scala-in-small-bites/">Learning Scala in Small Bites</a></li>
</ul>

<p>このガイドは生きたドキュメントであり、現在の「ベストプラクティス」が反映されていく。けれども、核となるアイデアは変わらない。常に可読性を優先せよ。ジェネリックなコードを書き、しかし明瞭さを犠牲にするな。シンプルな言語機能を利用せよ。それは偉大な力を与え、難解さを防ぐ（型システムでは特に）。とりわけ、トレードオフを常に意識すべきだ。洗練された言語は複雑な実装を必要とし、判断や、動作や、機能間の相互作用や、そして君の協力者に対する理解を困難にする。つまり、複雑さは洗練の税金なのだ。効用がコストを上回っていることを、常に確認しなければいけない。</p>

<p>では、楽しんでほしい。</p>

<p><a id="整形" /></p>

<h2>整形</h2>

<p>コード<em>整形</em>の詳細は、（それが実際的である限りは）重要じゃない。当然だが、スタイルに本質的な良し悪しはないし、たいていは人それぞれの個人的嗜好は異なる。だけど、同じ整形ルールを<em>一貫して</em>適用することは、ほぼ全ての場合で可読性を高める。特定のスタイルに馴染んだ読み手は、さらに他のローカルな習慣を理解したり、言語文法の隅っこを解読したりする必要がない。</p>

<p>これは文法の重複度が高いScalaにおいては特に重要だ。メソッド呼び出しを例に挙げよう。メソッドは、&ldquo;<code>.</code>&rdquo;を付けても、ホワイトスペースを付けても呼び出せる。同様に、ゼロまたは一つの引数を取るメソッドでは丸カッコを付けても良いし、付けなくても良い、といった風に。さらに、異なるスタイルのメソッド呼び出しは、異なる文法上の曖昧さを露呈する！ 注意深く選ばれた整形ルールを一貫して適用することで、人間と機械の両方にとって、多くの曖昧さを解決できるのは間違いない。</p>

<p>我々は、<a href="http://docs.scala-lang.org/style/">Scala style guide</a>を遵守すると同時に、以下に示すルールを追加した。</p>

<p><a id="整形-ホワイトスペース" /></p>

<h3>ホワイトスペース</h3>

<p>インデントはホワイトスペース2個。100カラムを超える行は避けよう。メソッドやクラス、オブジェクトの定義の間は一行空ける。</p>

<p><a id="整形-命名" /></p>

<h3>命名</h3>

<dl class="rules">
<dt>小さなスコープでは、短い名前を使う</dt>
<dd> <code>i</code>や<code>j</code>や<code>k</code>は、ループ内ではほとんど期待される。</dd>
<dt>より大きなスコープでは、より長い名前を使う</dt>
<dd>外部APIには、より長く意味のある説明的な名前を付けるべきだ。<code>Future.all</code>ではなく<code>Future.collect</code>のような。
</dd>
<dt>一般的な略語を使い、難解な略語を避ける</dt>
<dd>誰でも<code>ok</code>や<code>err</code>、<code>defn</code>が何を指すか知っている。一方で、<code>sfri</code>はそれほど一般的じゃない。</dd>
<dt>用法が異なるのに名前を再利用しない</dt>
<dd><code>val</code>を使おう。</dd>
<dt>予約名を <code>`</code> を使ってオーバーロードするのは避ける</dt>
<dd><code>`type</code>`の代わりに、<code>typ</code>とする。</dd>
<dt>副作用を伴う操作には動作を表す名前を付ける（訳注：能動態？）</dt>
<dd><code>user.setActive()</code>ではなく、<code>user.activate()</code>とする。</dd>
<dt>値を返すメソッドの名前は説明的に</dt>
<dd><code>src.defined</code>ではなく、<code>src.isDefined</code>とする。</dd>
<dt>getterの接頭に<code>get</code>を付けない</dt>
<dd>以前のルールの通り、これは冗長だ。<code>site.getCount</code>ではなく、<code>site.count</code>とする。</dd>
<dt>パッケージやオブジェクト内で既にカプセル化されている名前を繰り返さない</dt>
<dd><pre><code>object User {
  def getUser(id: Int): Option[User]
}</code></pre>よりも、
<pre><code>object User {
  def get(id: Int): Option[User]
}</code></pre>とする。<code>User.get</code>に比べて、<code>User.getUser</code>は何も情報を提供しないし、使うときに冗長だ。
</dd>
</dl>

<p><a id="整形-インポート" /></p>

<h3>インポート</h3>

<dl class="rules">
<dt>インポート行はアルファベット順にソートする</dt>
<dd>こうすることで、視覚的に調べやすいし自動化もしやすい。</dd>
<dt>同じパッケージから複数の名前をインポートするときは中カッコを使う</dt>
<dd><code>import com.twitter.concurrent.{Broker, Offer}</code></dd>
<dt>6つより多くの名前をインポートするときはワイルドカードを使う</dt>
<dd>e.g.: <code>import com.twitter.concurrent._</code>
<br />ワイルドカードを濫用しないこと。一部のパッケージは、大量の名前をエクスポートしている。</dd>
<dt>コレクションを使う時は、<code>scala.collections.immutable</code> あるいは <code>scala.collections.mutable</code> をインポートして名前を修飾する</dt>
<dd>可変(mutable)および不変(immutable)コレクションは、二重に名前を持っている。読み手のために、名前を修飾してどちらのコレクションを使っているのか明らかにしよう。 (e.g. "<code>immutable.Map</code>")</dd>
<dt>他のパッケージからの相対指定でインポートしない</dt>
<dd><pre><code>import com.twitter
import concurrent</code></pre>のようには書かず、以下のように曖昧さの無い書き方をしよう。<pre><code>import com.twitter.concurrent</code></pre></dd>
<dt>インポートはファイルの先頭に置く</dt>
<dd>読み手が、全てのインポートを一箇所で参照できるようにしよう。</dd>
</dl>

<p><a id="整形-中カッコ" /></p>

<h3>中カッコ</h3>

<p>中カッコは、複合式を作るのに使われる（&ldquo;モジュール言語&rdquo;では他の用途にも使われる）。そして、複合式の値は、リスト中の最後の式となる。単純な式に中カッコを使うのは避けよう。例えば、</p>

<pre><code>def square(x: Int) = x*x
</code></pre>

<p class="LP">と書く代わりに、構文的にメソッドの本体を見分けやすい</p>

<pre><code>def square(x: Int) = {
  x * x
}
</code></pre>

<p class="LP">と書きたいと思うかもしれない。しかし、最初の記法の方が、乱雑さが少なく読みやすい。明確にするのが目的でないなら、<em>構文的な儀礼</em>は避けよう。</p>

<p><a id="整形-パターンマッチ" /></p>

<h3>パターンマッチ</h3>

<p>適用できる場合は、関数定義の中ではパターンマッチを直接使おう。</p>

<pre><code>list map { item =&gt;
  item match {
    case Some(x) =&gt; x
    case None =&gt; default
  }
}
</code></pre>

<p class="LP">とする代わりに、matchを折り畳んで</p>

<pre><code>list map {
  case Some(x) =&gt; x
  case None =&gt; default
}
</code></pre>

<p class="LP">と書くと、リストの要素がmapされることが分かりやすい &mdash; the extra indirection does not elucidate. （←？）</p>

<p><a id="整形-コメント" /></p>

<h3>コメント</h3>

<p><a href="https://wiki.scala-lang.org/display/SW/Scaladoc">ScalaDoc</a>を使ってAPIドキュメントを提供しよう。以下のように書く:</p>

<pre><code>/**
 * ServiceBuilder builds services 
 * ...
 */
</code></pre>

<p class="LP">でも標準のScalaDocスタイルは<em>使わない</em>ように:</p>

<pre><code>/** ServiceBuilder builds services
 * ...
 */
</code></pre>

<p>アスキーアートや視覚的な装飾に頼ってはいけない。また、APIではない不必要なコメントをドキュメント化してはいけない。もし、自分のコードの挙動を説明するためにコメントを追加しているのに気づいたら、まずは、それが何をするコードなのか明白になるよう書き直せないか考え直してみよう。「見るからに、それは動作する (it works, obviously)」よりも「明らかにそれは動作する(obviously it works)」方が良い（ホーアには申し訳ないけど）。</p>

<p>（訳注: <a href="http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%88%E3%83%8B%E3%83%BC%E3%83%BB%E3%83%9B%E3%83%BC%E3%82%A2">アントニー・ホーア</a>は、自身のチューリング賞受賞講演の中で、<em>『極めて複雑に設計して「明らかな」欠陥を無くすより、非常に簡素に設計して「明らかに」欠陥が無いようにする方が遥かに難しい』</em>という趣旨の発言をしている。「コードから実装の意図を一目瞭然に読み取れるようにせよ」という主張は、上記のホーアの主張の真逆を言っている、ということだろう。）</p>

<p><a id="型とジェネリクス" /></p>

<h2>型とジェネリクス</h2>

<p>型システムの主な目的は、プログラミングの誤りを検出することだ。型システムは、限定的な方式の静的検査を効果的に提供する。これにより、コンパイラが検証可能なコードにおいて、ある種の不変条件を表現できる。型システムがもたらす恩恵はもちろん他にもあるが、エラーチェックこそ、その存在理由（レーゾンデートル）だ。</p>

<p>我々が型システムを使う場合はこの目的を踏まえるべきだが、一方で、読み手にも気を配り続けなきゃいけない。型を慎重に使ったコードは明瞭さが高まるが、過剰に巧妙に使ったコードは読みにくいだけだ。</p>

<p>Scalaの強力な型システムは、学術的な探求と演習においてよく題材とされる(eg. <a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">Type level programming in
Scala</a>)。これらのテクニックは学術的に興味深いトピックだが、プロダクションコードでの応用において有用であることは稀だ。避けるべきだろう。</p>

<p><a id="型とジェネリクス-戻り型アノテーション" /></p>

<h3>戻り型アノテーション</h3>

<p>Scalaでは戻り型アノテーション(return type annotation)を省略できるが、一方でそれらは良いドキュメンテーションであり、publicメソッドでは特に重要だ。露出していないメソッドで、戻り型が明白な場合は省略しよう。</p>

<p>これは、Scalaコンパイラが生成するシングルトン型をミックスインするオブジェクトをインスタンス化する場合は特に重要だ。例えば、<code>make</code> 関数が:</p>

<pre><code>trait Service
def make() = new Service {
  def getId = 123
}
</code></pre>

<p class="LP"><code>Service</code> という戻り型を<em>持たない</em>場合、コンパイラは細別型(refinement type)である <code>Object with Service{def getId: Int}</code> を生成する。代わりに、明示的なアノテーションを使うと:</p>

<pre><code>def make(): Service = new Service{}
</code></pre>

<p><code>make</code> の公開型を変更することなく、さらに好きなだけtraitをミックスできるから、後方互換性の管理が容易になる。</p>

<p><a id="型とジェネリクス-変位" /></p>

<h3>変位</h3>

<p>変位(variance)は、ジェネリクスが派生型と結びつく時に現れる。変位は、<em>コンテナ型</em>の派生型と、コンテナ型に<em>含まれる型</em>の派生型がどう関連するかを定義する。Scalaでは変位アノテーションを宣言できるから、コレクションに代表される共通ライブラリの作者は、多数のアノテーションを扱う必要がある。変位アノテーションは、共用コードの使い勝手を高める上で重要だが、誤用すると危険なものとなりうる。</p>

<p>変位は、Scalaの型システムにおいて、高度だが必須の特徴だ。変位は、派生型の適用を助けるものとして、大いに（そして正しく）使われるべきだ。</p>

<p><em>不変コレクションは共変であるべきだ</em>。要素型を受け取るメソッドは、コレクションを適切に&ldquo;格下げ&rdquo;すべきだ:</p>

<pre><code>trait Collection[+T] {
  def add[U &gt;: T](other: U): Collection[U]
}
</code></pre>

<p><em>可変コレクションは不変であるべきだ</em>。一般的に、可変コレクションにおいて共変は無効だ。この</p>

<pre><code>trait HashSet[+T] {
  def add[U &gt;: T](item: U)
}
</code></pre>

<p class="LP">と、以下の型階層を見てほしい:</p>

<pre><code>trait Mammal
trait Dog extends Mammal
trait Cat extends Mammal
</code></pre>

<p class="LP">もし今、犬(Dog)のハッシュセットがあるなら、</p>

<pre><code>val dogs: HashSet[Dog]
</code></pre>

<p class="LP">それを哺乳類(Mammal)の集合として扱ったり、猫(Cat)を追加したりできる。</p>

<pre><code>val mammals: HashSet[Mammal] = dogs
mammals.add(new Cat{})
</code></pre>

<p class="LP">これはもはや、犬のHashSetではない！</p>

<!--
  * when to use abstract type members?
  * show contravariance trick?
-->

<p><a id="型とジェネリクス-型エイリアス" /></p>

<h3>型エイリアス</h3>

<p>型エイリアス(type alias)は、簡便な名前を提供したり、意味を明瞭にするために使う。しかし、一目瞭然な型はエイリアスしない。</p>

<pre><code>() =&gt; Int
</code></pre>

<p class="LP">は、簡潔かつ一般的な型を使っているので、</p>

<pre><code>type IntMaker = () =&gt; Int
IntMaker
</code></pre>

<p class="LP">よりも明瞭だ。しかし、</p>

<pre><code>class ConcurrentPool[K, V] {
  type Queue = ConcurrentLinkedQueue[V]
  type Map   = ConcurrentHashMap[K, Queue]
  ...
}
</code></pre>

<p class="LP">は、意思疎通が目的で、簡潔さを高めたい場合に有用だ。</p>

<p>エイリアスが使える場合は、サブクラスを使ってはいけない。</p>

<pre><code>trait SocketFactory extends (SocketAddress) =&gt; Socket
</code></pre>

<p class="LP"><code>SocketFactory</code>は、<code>Socket</code>を生成する<em>関数</em>だ。型エイリアス</p>

<pre><code>type SocketFactory = SocketAddress =&gt; Socket
</code></pre>

<p class="LP">を使う方がいい。今や、<code>SocketFactory</code>型の値のための関数リテラルが与えられているので、関数合成を使うことができる:</p>

<pre><code>val addrToInet: SocketAddress =&gt; Long
val inetToSocket: Long =&gt; Socket

val factory: SocketFactory = addrToInet andThen inetToSocket
</code></pre>

<p>パッケージオブジェクトを使うと、型エイリアスをトップレベル名に結びつけられる:</p>

<pre><code>package com.twitter
package object net {
  type SocketFactory = (SocketAddress) =&gt; Socket
}
</code></pre>

<p>なお、型エイリアスは、型に対する別名の構文的な代わりとなるものであり、新しい型ではないことに留意しよう。</p>

<p><a id="型とジェネリクス-暗黙" /></p>

<h3>暗黙</h3>

<p>暗黙(implicit)は、型システムの強力な機能だが、慎重に使うべきだ。それらの解決ルールは複雑で、シンプルな字句検査においてさえ、実際に何が起きているか把握するのを困難にする。暗黙を間違いなく使ってもいいのは、以下の場面だ:</p>

<ul>
<li>Scalaスタイルのコレクションを拡張したり、追加したりするとき</li>
<li>オブジェクトを適合(adapt)させたり、拡張したりするとき（&ldquo;pimp my library&rdquo;パターン）</li>
<li><a href="http://www.ne.jp/asahi/hishidama/home/tech/scala/generics.html#h_generalized_type_constraints">制約エビデンス</a>を提供することで、<em>型安全を強化</em>するために使うとき</li>
<li>型エビデンス（型クラス）を提供するため</li>
<li><code>Manifest</code>のため</li>
</ul>

<p>暗黙を使う場合は、暗黙を使わずに同じことを達成する方法がないか、常に確認しよう。</p>

<p>似通ったデータ型同士を、自動的に変換するのに暗黙を使うのはやめよう（例えば、リストをストリームに変換する等）。型はそれぞれ異なった動作をするので、暗黙に型が変換されていないか、読み手に気を使わせることになる。明示的に変換するべきだ。</p>

<p><a id="コレクション" /></p>

<h2>コレクション</h2>

<p>Scalaが持つコレクションライブラリは、非常に総称的で、機能豊富で、強力で、組み合わせが容易だ。コレクションは高水準であり、多数の操作を提供している。多数のコレクション操作と変換を簡潔かつ読みやすく表現できるが、それらの機能を不注意に適用すると、しばしば正反対の結果を招く。全てのScalaプログラマは、<a href="http://www.scala-lang.org/docu/files/collections-api/collections.html">collections design document</a>を読むべきだ。このドキュメントは、Scalaのコレクションライブラリに対する優れた洞察と意欲をもたらしてくれる。</p>

<p>常に、君のニーズを最もシンプルに満たすコレクションを使おう。</p>

<p><a id="コレクション-階層" /></p>

<h3>階層</h3>

<p>コレクションライブラリは巨大だ。<code>Traversable[T]</code>を基底とする精密な階層に加えて、ほとんどのコレクションに<code>immutable</code>と<code>mutable</code>のバリエーションがある。複雑さはともかく、以下の図は、<code>immutable</code>と<code>mutable</code>の双方の階層にとって重要な区別を含んでいる。</p>

<p><img src="coll.png" style="margin-left: 3em;" /></p>

<p class="LP"><code>Iterable[T]</code>はイテレートできるコレクションで、<code>iterator</code>(と<code>foreach</code>)メソッドを提供する。<code>Seq[T]</code>は<em>順序付けされた</em>コレクション、<code>Set[T]</code>は数学的集合（要素が一意な順序の無いコレクション）、そして<code>Map[T]</code>は順序の無い連想配列だ。</p>

<p><a id="コレクション-利用" /></p>

<h3>利用</h3>

<p><em>不変(immutable)コレクションを利用する。</em>不変コレクションは、ほとんどの状況に適用できると同時に参照透過なので、プログラムがデフォルトでスレッドセーフであると判断しやすくなる。</p>

<p><em><code>mutable</code>名前空間は明示的に使う。</em><code>scala.collections.mutable._</code>をインポートして<code>Set</code>を参照する代わりに、</p>

<pre><code>import scala.collections.mutable
val set = mutable.Set()
</code></pre>

<p class="LP">とすることで、可変な`Set`を使っていることが分かりやすくなる。</p>

<p><em>コレクション型のデフォルトコンストラクタを使う。</em>例えば、順序付きの（かつ連結リストの動作が必要ない）シーケンスが欲しい場合は、いつでも<code>Seq()</code>コンストラクタを使おう:</p>

<pre><code>val seq = Seq(1, 2, 3)
val set = Set(1, 2, 3)
val map = Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;, 3 -&gt; &quot;three&quot;)
</code></pre>

<p class="LP">このスタイルでは、コレクションの動作がその実装と切り離されているので、コレクションライブラリは最も適切な実装型を使うことができる。君が必要としているのは<code>Map</code>であって、必ずしも赤黒木じゃない。さらに、これらのデフォルトコンストラクタは、しばしば特殊化した表現を用いる。例えば<code>Map()</code>は、3つのキーを持つマップに対して、3つのフィールドを持つオブジェクトを使う（訳注: [Map3](http://www.scala-lang.org/api/current/scala/collection/immutable/Map$$Map3.html)クラスのこと）。</p>

<p>以上からの結論として、メソッドやコンストラクタでは、<em>最も総称的なコレクション型を適切に受け取ろう</em>。これは詰まるところ、通常は上記の<code>Iterable</code>、<code>Seq</code>、<code>Set</code>あるいは<code>Map</code>のうち、どれか一つである。もしメソッドがシーケンスを必要とする場合は、<code>List[T]</code>ではなく<code>Seq[T]</code>を使おう。</p>

<!--
something about buffers for construction?
anything about streams?
-->

<p><a id="コレクション-スタイル" /></p>

<h3>スタイル</h3>

<p>関数型プログラミングでは、不変コレクションを望みの結果へと変形する方法として、パイプライン化された変換が推奨されている。大抵は、この手法により問題をとても簡潔に解決できるが、同時に読み手を困惑させることもある。変換をパイプライン化すると、しばしば作者の意図を理解するのが困難になり、暗黙的にしか示されていない途中結果を、全て追跡し続けるしかなくなるからだ。例えば、様々なプログラミング言語に対する投票結果である (language, num votes) のシーケンスを集計して、票数の最も多い言語から順番に表示するコードは、以下のように書ける:</p>

<pre><code>val votes = Seq((&quot;scala&quot;, 1), (&quot;java&quot;, 4), (&quot;scala&quot;, 10), (&quot;scala&quot;, 1), (&quot;python&quot;, 10))
val orderedVotes = votes
  .groupBy(_._1)
  .map { case (which, counts) =&gt; 
    (which, counts.foldLeft(0)(_ + _._2))
  }.toSeq
  .sortBy(_._2)
  .reverse
</code></pre>

<p class="LP">このコードは、簡潔でかつ正しい。しかし、ほとんどの読み手は、作者の元の意図を把握するのに苦労するだろう。<em>途中結果とパラメータに名前を付ける</em>のは、多くの場合で、作者の意図をハッキリさせるのに役立つ戦略の一つだ:</p>

<pre><code>val votesByLang = votes groupBy { case (lang, _) =&gt; lang }
val sumByLang = votesByLang map { case (lang, counts) =&gt;
  val countsOnly = counts map { case (_, count) =&gt; count }
  (lang, countsOnly.sum)
}
val orderedVotes = sumByLang.toSeq
  .sortBy { case (_, count) =&gt; count }
  .reverse
</code></pre>

<p class="LP">このコードでは、施される変換を中間値の名前に、操作されるデータ構造をパラメータ名にしている。これにより、以前と同じくらい簡潔であるだけでなく、作者の意図がよりいっそう明瞭に表現されている。もし、このスタイルを使うことで名前空間の汚染が心配なら、式を<code>{}</code>でグループ化すると良い:</p>

<pre><code>val orderedVotes = {
  val votesByLang = ...
  ...
}
</code></pre>

<p><a id="コレクション-性能" /></p>

<h3>性能</h3>

<p>高水準コレクションライブラリは、（高水準な構築物が一般的にそうであるように）性能の推測が難しい。コンピュータに直接指示するやり方、つまり命令型スタイルから遠ざかるほど、あるコード片が性能に与える影響を厳密に予測するのは困難になる。一方で、正確さを判断することは概して容易だし、読みやすさも向上する。Scalaの場合、Javaランタイムが事態をさらに複雑にしている。Scalaでは、ボクシング操作やアンボクシング操作がユーザから隠されており、性能やメモリ使用量の面で重大なペナルティを被ることがある。</p>

<p>低レベルの詳細に焦点を当てる前に、君のコレクションの使い方が適切かどうか確認しよう。また、データ構造に予期しない漸近的な複雑さがないか確かめよう。Scalaのさまざまなコレクションの複雑さについては、<a href="http://www.scala-lang.org/docu/files/collections-api/collections_40.html">こちら</a>で述べられている。</p>

<p>性能最適化の第一法則は、君のアプリケーションが<em>なぜ</em>遅いのかを理解することだ。最適化を始める前に、君のアプリケーションをプロファイル<a class="noteref" id="fnref1" href="#fn1" title="Jump to note 1">[1]</a>してデータを取ろう。最初に注目するのは、回数の多いループや巨大なデータ構造だ。最適化への過度な取り組みは、たいてい無駄な努力に終わる。クヌースの「時期尚早な最適化は諸悪の根源」という格言を思い出そう。</p>

<p>性能やメモリ使用効率の良さが要求される場面では、多くの場合、低レベルコレクションを使うのが妥当だ。巨大なシーケンスには、リストより配列を使おう（不変の<code>Vector</code>コレクションは、配列への参照透過なインタフェースを提供する）。また、性能が重要な場合は、シーケンスを直接生成せずにバッファを使おう。</p>

<p><a id="コレクション-Javaコレクション" /></p>

<h3>Javaコレクション</h3>

<p>Javaコレクションとの相互運用のために、<code>scala.collection.JavaConverters</code>を使おう。<code>JavaConverters</code>は、暗黙変換を行う<code>asJava</code>メソッドと<code>asScala</code>メソッドを追加する。読み手を助けるために、これらの変換は明示的に行うようにしよう:</p>

<pre><code>import scala.collection.JavaConverters._

val list: java.util.List[Int] = Seq(1,2,3,4).asJava
val buffer: scala.collection.mutable.Buffer[Int] = list.asScala
</code></pre>

<p><a id="並行性" /></p>

<h2>並行性</h2>

<p>現代のサービスは、サーバへの何万何十万もの同時操作を調整するため、高い並行性を備えている。そして、隠れた複雑性への対処は、堅固なシステムソフトウェアを記述する上で中心的なテーマだ。</p>

<p><em>スレッド</em>は、並行性を表現する一つの手段だ。スレッドからは、OSがスケジュールする、ヒープを共有する独立した実行コンテクストを利用できる。しかし、Javaにおいてスレッド生成はコストが高い。そのため、主にスレッドプールを使って、リソースとして管理する必要がある。これは、プログラマにとってさらなる複雑さを生み出す。また、アプリケーションロジックとそれが使用する潜在的なリソースを分離するのが難しくなり、結合度を高めてしまう。</p>

<p>この複雑さは、出力の大きいサービスの製作において、とりわけ明らかになる。それぞれの受信リクエストからは、システムのまた別の階層に対する多数のリクエストが生じる。それらのシステムにおいて、スレッドプールは、各階層でのリクエストの割合によってバランスするよう管理されなきゃならない。あるスレッドプールで管理に失敗すると、その影響は他のスレッドプールにも広がってしまう。</p>

<p>また、堅固なシステムは、タイムアウトとキャンセルについても検討する必要がある。どちらに対処するにも、さらなる「制御スレッド」の導入が必要で、そのことが問題をさらに複雑にする。ちなみに、もしスレッドのコストが安いなら、こうした問題は少なくなる。なぜなら、スレッドプールが必要とされず、タイムアウトスレッドを切り捨てることができ、追加のリソース管理も必要ないからだ。</p>

<p>このように、リソース管理はモジュール性を危うくするのだ。</p>

<p><a id="並行性-Future" /></p>

<h3>Future</h3>

<p>Futureを使って並行性を管理しよう。Futureは、並行操作とリソース管理を疎結合にする。例えば、<a href="http://github.com/twitter/finagle">Finagle</a>は、並行操作をわずかなスレッド数で効率的に多重化する。Scalaには、軽量なクロージャリテラルの構文がある。だから、Futureは構文上の負担が小さく、ほとんどのプログラマが身に付けることができる。</p>

<p>Futureは、プログラマが並行計算を宣言的なスタイルで表現できるようにする。Futureは合成可能で、また計算の失敗を原則に沿って処理できる。こうした性質から、Futureは関数型プログラミング言語にとても適しており、推奨されるスタイルだと確信している。</p>

<p><em>生成したFutureを変換しよう。</em>Futureの変換を使うと、失敗の伝播やキャンセルの通知が行われることを保証できる。また、プログラマは、Javaメモリモデルの影響を検討する必要がなくなる。RPCを順番に10回発行して結果を表示するとき、注意深いプログラマでさえ、以下のように書いてしまうかもしれない:</p>

<pre><code>val p = new Promise[List[Result]]
var results: List[Result] = Nil
def collect() {
  doRpc() onSuccess { result =&gt;
    results = result :: results
    if (results.length &lt; 10)
      collect()
    else
      p.setValue(results)
  } onFailure { t =&gt;
    p.setException(t)
  }
}

collect()
p onSuccess { results =&gt;
  printf(&quot;Got results %s\n&quot;, results.mkString(&quot;, &quot;))
}
</code></pre>

<p>RPCの失敗が確実に伝播するように、プログラマは、コードに制御フローをいくつも挿入する必要がある。さらに悪いことに、上記のコードは間違っている！ <code>results</code>を<code>volatile</code>として宣言していないので、各繰り返しにおいて、<code>results</code>が一つ前の値を保持していることを保証できない。Javaのメモリモデルは、油断ならない獣だ。しかし幸いにして、宣言的スタイルを使えば、これらの落とし穴を全て避けることができる:</p>

<pre><code>def collect(results: List[Result] = Nil): Future[List[Result]] =
  doRpc() flatMap { result =&gt;
    if (results.length &lt; 9)
      collect(result :: results)
    else
      result :: results
  }

collect() onSuccess { results =&gt;
  printf(&quot;Got results %s\n&quot;, results.mkString(&quot;, &quot;))
}
</code></pre>

<p>シーケンスの操作に<code>flatMap</code>を使うと、処理が進むにつれて、リストの先頭に結果を追加できる。これは、関数型プログラミングの一般的なイディオムを、Futureに置き換えたものだ。これは正しく動作するだけでなく、必要な「おまじない」を少なくでき、間違いの元を減らすことができる。そして、読みやすい。</p>

<p><em>Futureの結合子(combinator)を使おう。</em><code>Future.select</code>や<code>Future.join</code>、そして<code>Future.collect</code>は、複数のFutureを結合して操作する際の一般的なパターンを体系化している。</p>

<p><a id="並行性-コレクション" /></p>

<h3>コレクション</h3>

<p>並行コレクションの話題は、私見と、機微と、教義と、FUDに満ちている。それらは、多くの場合、実践において取るに足らない問題だ。いつでも、目的を果たす上で、最も単純で、最も退屈で、最も標準的なコレクションから始めよう。同期化コレクションでうまくいかないのが<em>分かる</em>前に、並行コレクションに手を伸ばしてはいけない。JVMは、同期を低コストで実現する洗練された機構を持っている。その有効性に、君は驚くはずだ。</p>

<p>不変(immutable)コレクションで目的を果たせるなら、それを使おう。不変コレクションは参照透過なので、並行コンテキストでの推論が簡単になる。不変コレクションの変更は、主に（<code>var</code>セルや<code>AtomicReference</code>が指す）現在の値への参照を更新することで行う。不変コレクションの変更を適用する際は、注意が必要だ。他のスレッドへ不変コレクションを公開する場合、<code>AtomicReference</code>には再試行が必要だし、<code>var</code>変数は<code>volatile</code>として宣言しなければいけない。</p>

<p>可変(mutable)な並行コレクションは複雑な動作をするだけでなく、Javaメモリモデルの微妙な部分を利用する。だから、可変並行コレクションが更新を公開する方法など、暗黙的な挙動について理解しておこう。また、コレクションの合成には同期化コレクションを使おう。並行コレクションでは、<code>getOrElseUpdate</code>のような操作を正しく実装できないし、特に、合成コレクションの作成はエラーの温床だ。</p>

<!--

use the stupid collections first, get fancy only when justified.

serialized? synchronized?

blah blah.

Async*?

-->

<p><a id="制御構造" /></p>

<h2>制御構造</h2>

<p>関数型スタイルで書くプログラムは、宣言型スタイルで書く場合より伝統的な制御構造が少なく済むことが多く、また読みやすい。関数型スタイルとは、典型的には、ロジックをいくつかの小さなメソッドや関数に分解し、それらを互いに<code>match</code>式で貼り合わせることを意味する。また、関数型プログラムは、より式指向となる傾向がある。つまり、条件式の分岐で同じ型の値を計算し、<code>for (..) yield</code>で内包(comprehension)を計算する。また、再帰を一般的に利用する。</p>

<p><a id="制御構造-再帰" /></p>

<h3>再帰</h3>

<p><em>再帰表現を使うと、問題をしばしば簡潔に記述できる。</em>そしてコンパイラは、末尾呼び出しの最適化が適用できるコードを、正規のループに置き換える（末尾最適化が適用されるかは<code>@tailrec</code>アノテーションで確認できる）。</p>

<p>ヒープの<span class="algo">fix-down</span>を、極めて標準的な命令型で実装したバージョンを検討しよう:</p>

<pre><code>def fixDown(heap: Array[T], m: Int, n: Int): Unit = {
  var k: Int = m
  while (n &gt;= 2*k) {
    var j = 2*k
    if (j &lt; n &amp;&amp; heap(j) &lt; heap(j + 1))
      j += 1
    if (heap(k) &gt;= heap(j))
      return
    else {
      swap(heap, k, j)
      k = j
    }
  }
}
</code></pre>

<p>このコードでは、whileループに入るたび、一つ前の反復で変更された状態を参照する。各変数の値は、どの分岐を取るかに依存する。また、正しい位置が見つかると、関数はループの中盤で<code>return</code>する（鋭い読者は、ダイクストラの<a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">&ldquo;Go To Statement Considered Harmful&rdquo;</a>に同様の議論があることに気づくと思う）。</p>

<p>（末尾）再帰による実装を検討してみよう<a class="noteref" id="fnref2" href="#fn2" title="Jump to note 2">[2]</a>:</p>

<pre><code>@tailrec
final def fixDown(heap: Array[T], i: Int, j: Int) {
  if (j &lt; i*2) return

  val m = if (j == i*2 || heap(2*i) &lt; heap(2*i+1)) 2*i else 2*i + 1
  if (heap(m) &lt; heap(i)) {
    swap(heap, i, m)
    fixDown(heap, m, j)
  }
}
</code></pre>

<p class="LP">ここでは、すべての反復ははっきりと<em>白紙の状態で</em>開始される。また、参照セルが存在しないため、不変条件を数多く見出せる。このコードはより推論しやすいだけでなく、より読みやすい。それだけでなく、性能面のペナルティもない。コンパイラはメソッドが末尾再帰なら、これを標準的な命令型のループへと変換するからだ。</p>

<p>（訳注: <a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%89%E3%82%AC%E3%83%BC%E3%83%BB%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9">エドガー・ダイクストラ</a>は、構造化プログラミングの提唱者。彼が執筆したエッセイ&ldquo;Go To Statement Considered Harmful&rdquo;は、「GOTO有害論」の端緒として有名。）</p>

<!--
elaborate..
-->

<p><a id="制御構造-Return" /></p>

<h3>Return</h3>

<p>前節では再帰を使うメリットを紹介したが、これは「命令型の構造は無価値だ」と言いたいわけじゃない。ほとんどの場合、計算を早期に打ち切る方が、終点の可能性がある全ての位置に条件分岐を持つよりも適切だ。実際に、上記の<code>fixDown</code>は、ヒープの終端に達すると<code>return</code>によって早期に終了する。</p>

<p><code>return</code>を使うと、分岐を省略して不変条件を確立できる。これにより、入れ子が減って読みやすくなるだけでなく、後続のコードの正当性を論証しやすくなる（配列の範囲外をアクセスしないことを確認する場合とか）。これは、&ldquo;ガード節&rdquo;で特に有用だ:</p>

<pre><code>def compare(a: AnyRef, b: AnyRef): Int = {
  if (a eq b)
    return 0

  val d = System.identityHashCode(a) compare System.identityHashCode(b)
  if (d != 0)
    return d

  // slow path..
}
</code></pre>

<p><code>return</code>を使って、コードを明快にして読みやすさを高めよう。ただし、命令型言語でのような使い方をしてはいけない。つまり、下記のように計算結果を返すために<code>return</code>を使うのは避けよう。</p>

<pre><code>def suffix(i: Int) = {
  if      (i == 1) return &quot;st&quot;
  else if (i == 2) return &quot;nd&quot;
  else if (i == 3) return &quot;rd&quot;
  else             return &quot;th&quot;
}
</code></pre>

<p class="LP">代わりに下記のように書こう:</p>

<pre><code>def suffix(i: Int) =
  if      (i == 1) &quot;st&quot;
  else if (i == 2) &quot;nd&quot;
  else if (i == 3) &quot;rd&quot;
  else             &quot;th&quot;
</code></pre>

<p class="LP">しかし、より優れているのは<code>match</code>式を使うことだ:</p>

<pre><code>def suffix(i: Int) = i match {
  case 1 =&gt; &quot;st&quot;
  case 2 =&gt; &quot;nd&quot;
  case 3 =&gt; &quot;rd&quot;
  case _ =&gt; &quot;th&quot;
}
</code></pre>

<p>なお、クロージャの内部で<code>return</code>を使うと、目に見えないコストが発生する場合があるので注意しよう。</p>

<pre><code>seq foreach { elem =&gt;
  if (elem.isLast)
    return

  // process...
}
</code></pre>

<p class="LP">このコードは、バイトコードでは例外の`throw`と`catch`として実装されるので、実行頻度の高いコードで使うと、性能に影響を与える。</p>

<p><a id="制御構造-`for`ループと内包" /></p>

<h3><code>for</code>ループと内包</h3>

<p><code>for</code>を使うと、ループと集約を簡潔かつ自然に表現できる。<code>for</code>は、多数のシーケンスを平坦化(flatten)する場合に特に有用だ。<code>for</code>の構文は、内部的にはクロージャを割り当てて呼び出していることを覆い隠している。このため、予期しないコストが発生したり、予想外の挙動を示したりする。例えば、</p>

<pre><code>for (item &lt;- container) {
  if (item != 2) return
}
</code></pre>

<p class="LP">このコードでは、<code>return</code>を非局所的(nonlocal)にするよう`container`が計算を遅延させると、ランタイムエラーが発生することがある！（訳注: どういう意味？）</p>

<p>これらの理由から、コードを明瞭にするためである場合を除いて、<code>for</code>を使う代わりに、<code>foreach</code>や<code>flatMap</code>や<code>map</code>や<code>filter</code>を直接呼び出す方が良いことが多い。</p>

<p><a id="制御構造-`require`と`assert`" /></p>

<h3><code>require</code>と<code>assert</code></h3>

<p><code>require</code>と<code>assert</code>は、どちらも実行可能なドキュメントとして機能する。これらは、要求される不変条件を型システムが表現できない状況で有用だ。<code>assert</code>は、コードが仮定する（内部あるいは外部の）<em>不変条件</em>を表現するために使われる。例えば、</p>

<pre><code>val stream = getClass.getResourceAsStream(&quot;someclassdata&quot;)
assert(stream != null)
</code></pre>

<p>一方で、<code>require</code>はAPIの契約を表現するために使われる:</p>

<pre><code>def fib(n: Int) = {
  require(n &gt; 0)
  ...
}
</code></pre>

<p><a id="関数型プログラミング" /></p>

<h2>関数型プログラミング</h2>

<p>関数型プログラミングと一緒に用いる時に <em>値指向型</em> プログラミングは多くの恩恵を受ける。このスタイルはステートフルな変更よりも値の変換を強調する。得られるコードは参照透過(referentially transparent)であり、より強力な不変式(invariants)を提供し、さらに容易に推論することが可能になる。ケースクラス、パターンマッチング、構造化代入(destructuring-bind)、型推論、軽量クロージャ、メソッド生成構文がこのツールになる。</p>

<p><a id="関数型プログラミング-代数的データ型としてのケースクラス" /></p>

<h3>代数的データ型としてのケースクラス</h3>

<p>ケースクラスは代数的データ型(ADT)をエンコードする。パターンマッチングと共に利用することで、ケースクラスは巨大なデータ構造をモデリングするのに役に立ち、強力な不変式を簡潔なコードとして提供する。パターンマッチャーは強力で静的保証を提供する包括的分析(exhaustivity analysis)を実装している。
ケースクラスと共に代数的データ型をエンコードする時、以下のパターンを使おう：</p>

<pre><code>sealed trait Tree[T]
case class Node[T](left: Tree[T], right: Tree[T]) extends Tree[T]
case class Leaf[T](value: T) extends Tree[T]
</code></pre>

<p><code>Tree[T]</code>の型は<code>Node</code>と<code>Leaf</code>の2つのコンストラクタを持つ。<code>sealed</code>として型を宣言する事で、ソースファイルの外からコンストラクタを追加することを制限できるため、コンパイラーに包括的分析(exhaustivity analysis)を行わせることができる。</p>

<p>パターンマッチと一緒に利用することで、そのようなモデリングを簡潔かつ&ldquo;明らかに正しい&rdquo;コードにすることができる。</p>

<pre><code>def findMin[T &lt;: Ordered[T]](tree: Tree[T]) = tree match {
  case Node(left, right) =&gt; Seq(findMin(left), findMin(right)).min
  case Leaf(value) =&gt; value
}
</code></pre>

<p>ツリーのような再帰構造は代数的データ型の古典的なアプリケーションを構成する一方で、それらの有用な領域はかなり大きい。
代数的データ型でモデリングされた結合の分解は状態遷移(state machines)で頻繁に発生する。</p>

<p><a id="関数型プログラミング-オプション" /></p>

<h3>オプション</h3>

<p><code>Option</code>型は、空であること(<code>None</code>)、または満たされていること(<code>Some(value)</code>)を表す容器である。<code>null</code>に対する安全な代替手段を提供し、可能な限り如何なる時も利用されるべきである。<code>Option</code>型は、たかだかひとつの要素を持つコレクションであり、コレクションの操作で装飾される。利用しよう！</p>

<p><code>Option</code>型は、無(<code>None</code>)か、有(<code>Some(Value)</code>)のどちらかを格納するコンテナである。nullの代わりに安全に使用でき、いつでも可能な限り使用されるべきである。
<code>Option</code>型は(たかだかひとつの一つの要素しかない)コレクションであり、集合の操作で利用できる。使うしかない!</p>

<p>以下のように書こう。</p>

<pre><code>var username: Option[String] = None
...
username = Some(&quot;foobar&quot;)
</code></pre>

<p class="LP">以下のようには書かない。</p>

<pre><code>var username: String = null
...
username = &quot;foobar&quot;
</code></pre>

<p class="LP">前者の方が安全な理由：<code>Option</code>型は<code>username</code>が空であることをチェックされなければならないことを静的に強要しているため。</p>

<p><code>Option</code>の値の条件節の実行は<code>foreach</code>を使うべきである。以下の代わりに、</p>

<pre><code>if (opt.isDefined)
  operate(opt.get)
</code></pre>

<p class="LP">以下のように書く</p>

<pre><code>opt foreach { value =&gt;
  operate(value)}
</code></pre>

<p>奇妙なスタイルに思えるかもしれないが、よりよい安全性を提供(例外を引き起こしうる<code>get</code>を呼んでいない)し、簡潔である。両方の選択肢が利用されうるなら、パターンマッチを使おう。</p>

<pre><code>opt match {
  case Some(value) =&gt; operate(value)
  case None =&gt; defaultAction()
}
</code></pre>

<p class="LP">しかし、もし値がない場合はデフォルト値で良いのであれば、<code>getOrElse</code>を使おう。</p>

<pre><code>operate(opt getOrElse defaultValue)
</code></pre>

<p><code>Option</code>を多用しすぎてはいけない。もし、何か目的にあったデフォルト値、<a href="http://en.wikipedia.org/wiki/Null_Object_pattern"><em>Null Object</em></a>、があるなら、代わりにそれを使おう。</p>

<p><code>Option</code>は、また、nullになり得る値を覆う扱いやすいコンストラクターと共に使おう。</p>

<pre><code>Option(getClass.getResourceAsStream(&quot;foo&quot;))
</code></pre>

<p class="LP">は、<code>Option[InputStream]</code> であり、<code>getResourceAsStream</code> が <code>null</code> を返す場合に、<code>None</code>  という値を返す。</p>

<p><a id="関数型プログラミング-パターンマッチ" /></p>

<h3>パターンマッチ</h3>

<p>パターンマッチ(<code>x match { ...</code>)は、書かれた Scala コードの見通しを良くする。パターンマッチは条件実行および非構造化(destructuring)、ひとつの構成物へのキャストを合成する。うまく使われたなら、明快さと安全さの両方をより高めてくれる。</p>

<p>型のスイッチを実装するためにパターンマッチを使う。</p>

<pre><code>obj match {
  case str: String =&gt; ...
  case addr: SocketAddress =&gt; ...
</code></pre>

<p>パターンマッチは、非構造化(destrcturing)とあわせて利用された時に最もよく動作する(たとえば、もしケースクラスをマッチングするなら)
次の例の代わりに</p>

<pre><code>animal match {
  case dog: Dog =&gt; &quot;dog (%s)&quot;.format(dog.breed)
  case _ =&gt; animal.species
  }
</code></pre>

<p class="LP">このように書く</p>

<pre><code>animal match {
  case Dog(breed) =&gt; &quot;dog (%s)&quot;.format(breed)
  case other =&gt; other.species
}
</code></pre>

<p><a href="http://www.scala-lang.org/node/112">カスタム抽出子</a> を書こう。しかし、二重コンストラクタ(<code>apply</code>) (dual constructor) と利用する場合のみだ。
そうでなければ、不適当な利用法になるかもしれない。
a dual constructor (<code>apply</code>), otherwise their use may be out of place.</p>

<p>デフォルト値が、もっと意味が取れるものであるとき条件実行にパターンマッチングを使わないようにする。
コレクションライブラリは通常<code>Option</code>を返すメソッドを提供する。次の例は避けよ。</p>

<pre><code>val x = list match {
  case head :: _ =&gt; head
  case Nil =&gt; default
}
</code></pre>

<p class="LP">なぜなら</p>

<pre><code>val x = list.headOption getOrElse default
</code></pre>

<p class="LP">は、より短く、意図を伝達する。</p>

<p><a id="関数型プログラミング-部分関数" /></p>

<h3>部分関数</h3>

<p>Scala は <code>PartialFunction</code> を定義するための構文上の簡略的記法を提供する。</p>

<pre><code>val pf: PartialFunction[Int, String] = {
  case i if i%2 == 0 =&gt; &quot;even&quot;
}
</code></pre>

<p class="LP">また、<code>orElse</code> と組み合わせられるかもしれない。</p>

<pre><code>val tf: (Int =&gt; String) = pf orElse { case _ =&gt; &quot;odd&quot;}

tf(1) == &quot;odd&quot;
tf(2) == &quot;even&quot;
</code></pre>

<p>部分関数は多くの場面で起こり得るし，たとえば、メソッドの引数として、<code>PartialFunction</code>で効果的に符号化される。</p>

<pre><code>trait Publisher[T] {
  def subscribe(f: PartialFunction[T, Unit])
}

val publisher: Publisher[Int] = ..
publisher.subscribe {
  case i if isPrime(i) =&gt; println(&quot;found prime&quot;, i)
  case i if i%2 == 0 =&gt; count += 2
  /* ignore the rest */
}
</code></pre>

<p class="LP">もしくは <code>Option</code> を返すような呼び出しの場面において、</p>

<pre><code>// Attempt to classify the the throwable for logging.
type Classifier = Throwable =&gt; Option[java.util.logging.Level]
</code></pre>

<p class="LP">は、<code>PartialFunction</code>で表現される方がよりよいかもしれない。</p>

<pre><code>type Classifier = PartialFunction[Throwable, java.util.Logging.Level]
</code></pre>

<p class="LP">より優れた構成可能性(composability)を与えるからだ。</p>

<pre><code>val classifier1: Classifier
val classifier2: Classifier

val classifier = classifier1 orElse classifier2 orElse { _ =&gt; java.util.Logging.Level.FINEST }
</code></pre>

<p><a id="関数型プログラミング-分配束縛(Destructuring bindings)" /></p>

<h3>分配束縛(Destructuring bindings)</h3>

<p>分配値束縛は、パターンマッチングに関係している。同じメカニズムを利用しているが、
(例外の可能性を許容しないために)正確にひとつの選択肢があるときだけ適用可能である。
分配束縛は特にタプルとケースクラスで有用である。</p>

<pre><code>val tuple = ('a', 1)
val (char, digit) = tuple

val tweet = Tweet(&quot;just tweeting&quot;, Time.now)
val Tweet(text, timestamp) = tweet
</code></pre>

<p><a id="関数型プログラミング-遅延" /></p>

<h3>遅延</h3>

<p>Scala のフィールドは、<code>val</code> が <code>lazy</code> プレフィックスと共に使われた時は <em>必要に応じて</em> 演算される。
なぜなら、フィールドとメソッドは Scala では等価だからである(フィールドが <code>private[this]</code> にならないように)。</p>

<pre><code>lazy val field = computation()
</code></pre>

<p class="LP">は、(概して) 簡略的記法で、</p>

<pre><code>var _theField = None
def field = if (_theField.isDefined) _theField.get else {
  _theField = Some(computation())
  _theField.get
}
</code></pre>

<p class="LP">すなわち、結果を演算し記憶する。この目的のために遅延フィールドを使うようにし、しかし、遅延がセマンティクスによって要求されるときに遅延を使うことを避ける。</p>

<p>このようなケースにおいて、コストモデルを明確にし、副作用がより正確に制御されるから、明示的であることがよりよい。</p>

<p>遅延フィールドはスレッドセーフである。</p>

<p><a id="関数型プログラミング-名前呼び出し" /></p>

<h3>名前呼び出し</h3>

<p>メソッドのパラメーターは名前によって特定されるかもしれない、その意味するところは
パラメータは値に紐付くのではなくて、繰り返されうる <em>演算</em> に対して紐付くということである。
この機能は気をつけて適用されなければならない。値渡しの文脈を期待している呼び出し側は驚くであろう。
この機能の動機は構文的に自然な DSL を構築することにある。&mdash; 新しい制御構造は特に、かなりネイティブな言語機能に見えるように作ることができる</p>

<p>名前呼び出しは、そのような制御構造のためだけに使うことだ。そこでは、渡されてくるものは、
思いも寄らない演算結果より&ldquo;ブロック&rdquo;であるということが、呼び出し側に明らかである。
名前呼び出しは、最後の引数リストの最後の位置にある引数にだけ使うことだ。
名前呼び出しを使うときは、呼び出し側にその引数が名前呼び出しであることが明確に伝わるようにメソッドには名称をつけることを確実におこなう。</p>

<p>値を複数回演算させたいとき、また特にその演算が副作用を持つとき、陽関数(explicit functions)を使う。</p>

<pre><code>class SSLConnector(mkEngine: () =&gt; SSLEngine)
</code></pre>

<p class="LP">その意図は明確なままであり、呼び出し側が驚かずに済む。</p>

<p><a id="関数型プログラミング-`flatMap`" /></p>

<h3><code>flatMap</code></h3>

<p><code>map</code> と <code>flatten</code> の合成である <code>flatMap</code> は、鋭敏な力と素晴らしい実用性を持ち、特別な注目を浴びるに値する。
その同類である <code>map</code> のように、<code>Future</code> や <code>Option</code> といった非伝統的なコレクションにおいて、しばしば利用可能である。
その振る舞いは、<code>Container[A]</code>といったシグネチャによって明らかになる。</p>

<pre><code>flatMap[B](f: A =&gt; Container[B]): Container[B]
</code></pre>

<p class="LP"><code>flatMap</code> は、<em>新しい</em> コレクションを生成するコレクションの各要素に対して関数 <code>f</code> を呼び出し、それら(のすべて)は、</p>

<p>フラットな結果になる。例えば、次のコードは、同じ文字が繰り返されない2文字からなる文字列の順列をすべて取得する。</p>

<pre><code>val chars = 'a' to 'z'
val perms = chars flatMap { a =&gt;
  chars flatMap { b =&gt;
    if (a != b) Seq(&quot;%c%c&quot;.format(a, b))
    else Seq()
  }
}
</code></pre>

<p class="LP">これは、より簡潔な for による包含に等価である。(それは、&mdash; 荒くまとめるなら &mdash; 上記のためのシンタックスシュガーである)</p>

<pre><code>val perms = for {
  a &lt;- chars
  b &lt;- chars
  if a != b
} yield &quot;%c%c&quot;.format(a, b)
</code></pre>

<p><code>flatMap</code> は、しばしば <code>Options</code> を扱うときに有用である。 &mdash; オプションの連鎖(chain of options)を流れ落ちてひとつになる。</p>

<pre><code>val host: Option[String] = ..
val port: Option[Int] = ..

val addr: Option[InetSocketAddress] =
  host flatMap { h =&gt;
    port map { p =&gt;
      new InetSocketAddress(h, p)
    }
  }
</code></pre>

<p class="LP">これも、<code>for</code> により、より簡潔に記述できる。</p>

<pre><code>val addr: Option[InetSocketAddress] = for {
  h &lt;- host
  p &lt;- port
} yield new InetSocketAddress(h, p)
</code></pre>

<p><code>Future</code> における <code>flatMap</code> の利用については、<a href="#Twitter's%20standard%20libraries-Futures">futures section</a> で言及している。</p>

<p><a id="オブジェクト指向プログラミング" /></p>

<h2>オブジェクト指向プログラミング</h2>

<p>Scala の広大さの多くはオブジェクト機構にある。Scala は、<em>すべての値が</em>オブジェクトであるという意味で、<em>純粋な</em> 言語である。プリミティブな型と混合型の間に違いはない。 Scala はミックスインの機能もあり、静的型チェックの利益をすべて享受しつつ、もっと直行して別々なモジュールをコンパイル時に柔軟に一緒に組立てができる。</p>

<p>ミックスイン機構の背景ある動機は、伝統的な依存性注入の必要性を不要にするためにある。その&ldquo;コンポーネントスタイル&rdquo;のプログラミングの最高点は、<a href="http://jboner.github.com/2008/10/06/real-world-scala-dependency-injection-di.html"> Cake
パターン</a> である。</p>

<p><a id="オブジェクト指向プログラミング-依存性注入" /></p>

<h3>依存性注入</h3>

<p>私たちの利用では、しかし、Scala それ自身が、”クラシックな”(コンストラクタによる)依存性注入の多くの構文上のオーバーヘッドは、むしろそれを使う。それはより明快であり、依存性は(コンストラクタの)型でまだエンコードされ、クラスの組立は、とても構文的に些細であり、そよ風くらいになる。</p>

<p>それは退屈でシンプルだが動作する。<em>プログラムのモジュール化のために依存性注入を使うこと</em>。特に、<em>継承より合成を選択すること</em> 。 これにより、もっとモジュール化が進みテスト可能なプログラムになる。継承が必要な状況に遭遇した時、自分自身に問うのだ：もし言語が継承をサポートしていなかったら、どのように構造化するだろう、と。この答えは強いることができるかもしれない。</p>

<p>依存性注入は典型的にはトレイトを利用する。</p>

<pre><code> trait TweetStream {
   def subscribe(f: Tweet =&gt; Unit)
 }
 class HosebirdStream extends TweetStream ...
 class FileStream extends TweetStream ..

 class TweetCounter(stream: TweetStream) {
   stream.subscribe { tweet =&gt; count += 1 }
 }
</code></pre>

<p><em>ファクトリー</em>(オブジェクトを生成するオブジェクト)を注入することは一般的である。これら(下記のような？？)のケースでは、特化したファクトリー型よりはシンプルな関数の利用を好むようにする。</p>

<pre><code> class FilteredTweetCounter(mkStream: Filter =&gt; TweetStream) {
   mkStream(PublicTweets).subscribe { tweet =&gt; publicCount += 1 }
   mkStream(DMs).subscribe { tweet =&gt; dmCount += 1 }
 }
</code></pre>

<p><a id="オブジェクト指向プログラミング-トレイト" /></p>

<h3>トレイト</h3>

<p>依存性注入は、一般的な<em>インターフェイス</em>の利用や、トレイトで共通のコードを実装することを妨げるものでは全くない。全く反対なのだが、トレイトの利用は次の理由で強く推奨されている：複数のインターフェイス(トレイト)は、具象クラスで実装されるかもしれないし、共通コードはすべてのそれらのクラス群に横断的に再利用されるかもしれない。</p>

<p>トレイトは短くて直交するように保つことだ。分割可能な機能をひとつのトレイトの塊にしてしまってはいけない。最も小さな関連するアイデアだけを一緒にすることを考えるようにする。たとえば、IOをする何かを想像してみるといい。</p>

<pre><code> trait IOer {
   def write(bytes: Array[Byte])
   def read(n: Int): Array[Byte]
 }
</code></pre>

<p class="LP">これを２つの振る舞いに分離する。</p>

<pre><code> trait Reader {
   def read(n: Int): Array[Byte]
 }
 trait Writer {
   def write(bytes: Array[Byte])
 }
</code></pre>

<p class="LP">そして、もともと<code>IOer</code> だったこれらをミックスしてみる: <code>new Reader with Writer</code>&hellip;  インターフェイスの最小化は、よりよい直交性とよりよりモジュール化につながる。</p>

<p><a id="オブジェクト指向プログラミング-可視性" /></p>

<h3>可視性</h3>

<p>Scala は非常に表現豊かな可視性の修飾子を持つ。修飾子は、何を<em>公開API</em>として構成するかを定義するのに重要である。公開APIは限定されるべきであり、それにより利用者は不注意に実装の詳細に依存することはなく、また、作者のAPIを変更する力を制限する。このことは、良いモジュール性にとって決定的に重要である。ルールとして、公開APIを拡張することは、彼らと契約するよりもかなり簡単である。貧相なアノテーションは、君のコードの後方バイナリ互換性を汚すこともできるようにもなる。</p>

<h4><code>private[this]</code></h4>

<p><code>private</code> にしたクラスメンバーは、</p>

<pre><code> private val x: Int = ...
</code></pre>

<p class="LP">そのクラスの(しかし、サブクラスは含まずに)すべての<em>インスタンス</em>から見える。殆どの場合、君は<code>private[this]</code>としたいだろう。</p>

<pre><code> private[this] val: Int = ..
</code></pre>

<p class="LP">これは特定のインスタンスに可視性を制限する。Scala コンパイラーは、<code>private[this]</code> を(アクセスが静的に定義されたクラスに限られるから)シンプルなフィールドアクセッサに変換することもでき、それは時々、性能を最適化することに寄与する。</p>

<h4>シングルトンクラス型(？正確な訳？)</h4>

<p>Scala では、シングルトンクラス型を生成するのは一般的である。例えば、</p>

<pre><code> def foo() = new Foo with Bar with Baz {
   ...
 }
</code></pre>

<p class="LP">このような状況では、戻り型を宣言することで可視性は限定される。</p>

<pre><code> def foo(): Foo with Bar = new Foo with Bar with Baz {
   ...
 }
</code></pre>

<p class="LP"><code>foo()</code> の呼び出し側は、戻されたインスタンスの限定されたビュー(<code>Foo with Bar</code>) が参照できる</p>

<p><a id="オブジェクト指向プログラミング-構造的型(？正確な訳？)" /></p>

<h3>構造的型(？正確な訳？)</h3>

<p>通常の使用では構造的型は使わない。構造的型は、便利で強力な機能であるが、残念あんことにJVM上では効率的な実装手段はない。しかし、ある運命のいたずらともいうべき実装によって、リフレクションをするためのとても良い速記法を提供する。</p>

<pre><code> val obj: AnyRef
 obj.asInstanceOf[{def close()}].close()
</code></pre>

<p><a id="ガベージコレクション" /></p>

<h2>ガベージコレクション</h2>

<p>我々は、運用時にガベージコレクションのチューニングに多くの時間を費やす。
ガベージコレクションの考慮事項はかなりJavaのそれに似ているが、典型的な Scala コードの場合は 典型的な Java コードより多くの(生存時間の短い)ガベージを生成する。これは関数スタイルの副作用なのである。HotSpot の世代別ガベージコレクションは、ほとんどの環境では生存時間の短いガベージを効果的に解放するので、概してこれは問題にならない。</p>

<p>GCの性能問題に取り組む前に、Attila が発表した我々のGCチューニングに関する経験のいくつかに関する<a href="http://www.infoq.com/presentations/JVM-Performance-Tuning-twitter">プレゼンテーション</a>を見て欲しい。</p>

<p>Scala 固有で、GC問題を軽減する唯一のツールは、ガベージの生成をより少なくすることである。しかし、データなしで行動してはならない！もし、明らかに悪化させる何かをしているわけではないのであれば、我々の提供する <a href="https://github.com/mariusaeriksen/heapster">heapster</a> や
<a href="https://github.com/twitter/jvmgcprof">gcprof</a> を含む、Java の様々なプロファイルツールを使うことだ。</p>

<p><a id="Java 互換性" /></p>

<h2>Java 互換性</h2>

<p>我々は、Scala コードをJavaで利用するとき、Javaでの使い方を慣用的に残して良いものか確かめるようにしている。大体は余計な努力は必要ない。クラス群と実装を含まないトレイトはJava に正確に等価に対応される。しかし、時々、別にJava APIを提供する必要がある。あなたのライブラリのJava API の感じをつかむ良い方法は単体テストをJavaで書くことである(ただコンパイルが通れば良い)。この点については Scala コンパイラーは不安定であるのだが、このテストによって、あなたのライブラリの Java 視点は安定さを維持できる。</p>

<p>実装を含むトレイトは直接 Java から利用できない。代わりに抽象クラスをトレイトと共に拡張する必要がある。</p>

<pre><code> // 直接 Java から利用できない
 trait Animal {
   def eat(other: Animal)
   def eatMany(animals: Seq[Animal) = animals foreach(eat(_))
 }

 // しかし、これはできる
 abstract class JavaAnimal extends Animal
</code></pre>

<p><a id="Twitterの標準ライブラリ" /></p>

<h2>Twitterの標準ライブラリ</h2>

<p>Twitterにおいて、最も重要な標準ライブラリは<a href="http://github.com/twitter/util">Util</a>と<a href="https://github.com/twitter/finagle">Finagle</a>だ。Utilは、ScalaやJavaの標準ライブラリの拡張という位置付けで、それらに欠けている機能やより適切な実装を提供する。Finagleは、TwitterのRPCシステムで、分散システムの構成要素の中核だ。</p>

<p><a id="Twitterの標準ライブラリ-Futures" /></p>

<h3>Futures</h3>

<p>Futureについては、<a href="#並行性">並行性</a>の章でも少し<a href="#並行性-Future">議論した</a>。Futureは、非同期処理の連係において重要な機構で、TwitterのコードベースやFinagleのコアで広く使われている。Futureは、並行イベントの合成(composition)を可能にすると共に、高度な並行操作についての判断を単純化する。また、Futureを使うと、並行操作をJVM上で極めて効率的に実装できる。</p>

<p>ネットワーク入出力やディスク入出力等の操作は、基本的にスレッドの実行を一時停止する可能性がある。TwitterのFutureは<em>非同期的</em>なので、ブロックする操作(blocking operation)は、操作結果に対するFutureを提供するシステム自身によって処理されなければいけない。Finagleは、ネットワーク入出力のためのそうしたシステムを提供する。</p>

<p>Futureは、単純明白だ。Futureは、まだ完了していない計算の結果に対する<em>約束(promise)</em>を保持する、単純なコンテナ（プレースホルダ）だ。当然、計算は失敗することがあるので、このこともコード化する必要がある。Futureは三つの状態、すなわち<em>保留(pending)</em>、<em>失敗(failed)</em>、<em>完了(completed)</em>のうち、きっかり一つの状態を取ることができる。</p>

<div class="explainer">
<h3>余談: <em>合成(composition)</em></h3>
<p>もう一度確認すると、合成とは、単純なコンポーネントを結合してより複雑なコンポーネントにすることだ。合成の標準的な例は、関数合成だ。関数<em>f</em>と<em>g</em>が与えられたとき、合成関数<em>(g&#8728;f)(x) = g(f(x))</em>は、まず<em>x</em>を<em>f</em>に適用し、その結果を<em>g</em>に適用した結果だ。この合成関数をScalaで書くと:</p>

<pre><code>val f = (i: Int) => i.toString
val g = (s: String) => s+s+s
val h = g compose f  // : Int => String
    
scala> h(123)
res0: java.lang.String = 123123123</code></pre>

<p class="LP">この関数<em>h</em>は合成関数で、<em>f</em>と<em>g</em>の双方を所定の方法で結合した<em>新しい</em>関数だ。</p>
</div>

<p>Futureは、ゼロ個あるいは一個の要素を持つコンテナであり、コレクションの一種だ。Futureは、<code>map</code>や<code>filter</code>や<code>foreach</code>といった、標準コレクションのメソッドを持つ。Futureの値は遅延されるので、必然的にこれらのコレクションメソッドを適用した結果もまた遅延される。</p>

<pre><code>val result: Future[Int]
val resultStr: Future[String] = result map { i =&gt; i.toString }
</code></pre>

<p class="LP">関数<code>{ i => i.toString }</code>は、Int値が利用可能になるまで呼び出されない。また、変換されたコレクションである<code>resultStr</code>も、その時まで保留状態(pending state)になる。</p>

<p>リストは平坦化(flatten)できる;</p>

<pre><code>val listOfList: List[List[Int]] = ..
val list: List[Int] = listOfList.flatten
</code></pre>

<p class="LP">また、平坦化はFutureにおいても意味をなす:</p>

<pre><code>val futureOfFuture: Future[Future[Int]] = ..
val future: Future[Int] = futureOfFuture.flatten
</code></pre>

<p class="LP">Futureの<code>flatten</code>の実装は、直ちにFutureを返す。Futureは遅延するので、<code>flatten</code>が返すFutureは、外側のFuture(<code><b>Future[</b>Future[Int]<b>]</b></code>)の完了と、その後に内側のFuture(<code>Future[<b>Future[Int]</b>]</code>)の完了を待つ結果だ。また、外側のFutureが失敗したら、平坦化されたFutureも失敗する必要がある。</p>

<p>Futureは、Listと同様に<code>flatMap</code>を定義している。<code>Future[A]</code>は、そのシグネチャを以下のように定義する。</p>

<pre><code>flatMap[B](f: A =&gt; Future[B]): Future[B]
</code></pre>

<p class="LP">`flatMap`は、<code>map</code>と<code>flatten</code>の組み合わせのようなもので、以下のように実装できる:</p>

<pre><code>def flatMap[B](f: A =&gt; Future[B]): Future[B] = {
  val mapped: Future[Future[B]] = this map f
  val flattened: Future[B] = mapped.flatten
  flattened
}
</code></pre>

<p>これは、強力な組み合わせだ！ <code>flatMap</code>によって、二番目のFutureを最初のFutureの結果に基づいて計算する、順番に並べられた二つのFutureの結果である新しいFutureを定義できる。ユーザ(ID)を認証するために、二つのRPCを実行する必要がある場合を想像してほしい。この場合、合成された操作を以下の方法で定義できる:</p>

<pre><code>def getUser(id: Int): Future[User]
def authenticate(user: User): Future[Boolean]

def isIdAuthed(id: Int): Future[Boolean] = 
  getUser(id) flatMap { user =&gt; authenticate(user) }
</code></pre>

<p class="LP">この種の結合のもう一つの恩恵は、エラー処理が組み込まれていることだ。<code>getUser(..)</code>か<code>authenticate(..)</code>が追加でエラー処理をしない限り、<code>isAuthed(..)</code>が返すFutureは失敗するだろう。</p>

<h4>スタイル</h4>

<p>Futureのコールバックメソッドである<code>respond</code>や<code>onSuccess'、</code>onFailure<code>、</code>ensure`は、その親に<em>連鎖した(chained)</em>新たなFutureを返す。このFutureは、その親が完了して初めて完了することが保証されている。このパターンを実現するには、例えば以下のようにする。</p>

<pre><code>acquireResource()
future onSuccess { value =&gt;
  computeSomething(value)
} ensure {
  freeResource()
}
</code></pre>

<p class="LP">このとき<code>freeResource()</code>は、<code>computeSomething</code>の後にのみ実行されることが保証される。これにより、ネイティブな<code>try .. finally</code>パターンのエミュレートが可能になる。</p>

<p><code>foreach</code>の代わりに<code>onSuccess</code>を使おう。<code>onSuccess</code>の方が<code>onFailure</code>と対称を成して目的をより良く表せるし、連鎖も可能になる。</p>

<p>できるだけ自分で<code>Promise</code>を作らないようにしよう。ほぼ全てのタスクは、定義済みの結合子を使って実現できる。結合子は、エラーやキャンセルが伝播することを保証すると共に、一般的に<em>データフロー方式</em>でのプログラミングを促進する。データフロー方式を使うと、大抵、<a href="#並行性-Future">同期化や<code>volatile</code>宣言が不要になる</a>。</p>

<p>末尾再帰方式で書かれたコードはスペースリークに影響されないので、データフロー方式を使ってループを効率的に実装できる:</p>

<pre><code>case class Node(parent: Option[Node], ...)
def getNode(id: Int): Future[Node] = ...

def getHierarchy(id: Int, nodes: List[Node] = Nil): Future[Node] =
  getNode(id) flatMap {
    case n@Node(Some(parent), ..) =&gt; getHierarchy(parent, n :: nodes)
    case n =&gt; Future.value((n :: nodes).reverse)
  }
</code></pre>

<p><code>Future</code>は、数多くの有用なメソッドを定義している。<code>Future.value()</code>や<code>Future.exception()</code>を使うと、事前に結果が満たされたFutureを作れる。<code>Future.collect()</code>や<code>Future.join()</code>、<code>Future.select()</code>は、複数のFutureを一つにまとめる結合子を提供する（ie. scatter-gather操作のgather部分）。</p>

<p>（訳注: スペースリーク(space leak)とは、意図せずに巨大な空間計算量のコードを書いてしまうこと。関数型プログラミングでは、遅延評価式を未評価のまま蓄積するようなコードを書くと起きやすい。）</p>

<h4>キャンセル</h4>

<p>Futureは、弱いキャンセルを実装している。<code>Future#cancel</code>の呼び出しは、計算を直ちに終了させるのではなく、レベルトリガ方式の<em>シグナル</em>を伝播する。最終的にFutureを満たすのがいずれの処理であっても、シグナルに問い合わせる(query)ことができる。キャンセルは、値から反対方向へ伝播する。つまり、消費者(consumer)がセットしたキャンセルのシグナルは、対応する生産者(producer)へと伝播する。生産者は<code>Promise</code>にある<code>onCancellation</code>を使って、シグナルに応じて作動するリスナーを指定する。</p>

<p>つまり、キャンセルの動作は生産者に依存し、デフォルトの実装は存在しない。<em>キャンセルはヒントに過ぎない。</em></p>

<h4>Locals</h4>

<p>Util&rsquo;s
<a href="https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Local.scala#L40"><code>Local</code></a>
provides a reference cell that is local to a particular future dispatch tree. Setting the value of a local makes this
value available to any computation deferred by a Future in the same thread. They are analagous to thread locals,
except their scope is not a Java thread but a tree of &ldquo;future threads&rdquo;. In</p>

<pre><code>trait User {
  def name: String
  def incrCost(points: Int)
}
val user = new Local[User]

...

user() = currentUser
rpc() ensure {
  user().incrCost(10)
}
</code></pre>

<p class="LP"><code>user()</code> in the <code>ensure</code> block will refer to the value of the <code>user</code> local at the time the callback was added.</p>

<p>As with thread locals, <code>Local</code>s can be very convenient, but should
almost always be avoided: make sure the problem cannot be sufficiently
solved by passing data around explicitly, even if it is somewhat
burdensome.</p>

<p>Locals are used effectively by core libraries for <em>very</em> common
concerns &mdash; threading through RPC traces, propagating monitors,
creating &ldquo;stack traces&rdquo; for future callbacks &mdash; where any other solution
would unduly burden the user. Locals are inappropriate in almost any
other situation.</p>

<!--
  ### Offer/Broker

-->

<p><a id="Acknowledgments" /></p>

<h2>Acknowledgments</h2>

<p>The lessons herein are those of Twitter&rsquo;s Scala community &mdash; I hope
I&rsquo;ve been a faithful chronicler.</p>

<p>Blake Matheny, Nick Kallen, and Steve Gury provided much helpful
guidance and many excellent suggestions.</p>

<hr/>
<ol id="notes">

<li id="fn1">
<a href="http://yourkit.com">Yourkit</a>は良いプロファイラだ。 <a href="#fnref1" title="Jump back to reference">[back]</a></li>
<li id="fn2">
<a href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/Heap.scala#L41">Finagle&rsquo;s heap
balancer</a>より <a href="#fnref2" title="Jump back to reference">[back]</a></li>
</ol>

<center class="footer">
Copyright &copy; 2012 Twitter Inc.<br>
Licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>
<!--
<a href="http://creativecommons.org/licenses/by/3.0/"><img style="bottom: 0; right: 0; border: 0;" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a>
-->
</center>

</body>
</html>
